# vue-3
vue-饿了吗

# 问题

<li>代理的饿了吗后台好像不太稳定，有时候会出现请求失败，状态码为430</li>
<li>id=app、router-view标签为什么在根目录的index.html页面和App.vue文件中重复出现两次</li>
<li>@import "@/style/mixin"报错</li>
<li>vue代码进行调试的时候，总感觉有些卡顿</li>
<li>router的模式为history的时候，会影响回退页面的滚动条的起始位置,切换为hash模式就好了</li>
<li>hash与history俩种模式有什么区别</li>
<li>
hash模式路由地址会带上#,但是浏览器发送给服务器的却是#之前的URL。
hash模式的好处是，虽然你是个单页面应用，但是你可以只刷新当前页，而不必刷新整个单页面应用。
history模式的话需要服务端配合，如果服务器配置仅仅是找不到对应的路由，就会重定向到index.html，
那么刷新当前页会跳首页。如果服务器对于匹配不到URL不做配置，那么一般返回404页面。
</li>
<li>需要系统学习一下svg</li>
<li>
v-for指令可用于遍历数组和对象。<br>
遍历数组时： (item,index) in arr<br>
遍历对象时： (value,key,index) in obj
</li>
<li>
slot标签用于父组件向子组件分发想要显示的内容。<br>
slot标签使用场景几个父组件公用一个子组件，且想要该子组件在不同的父组件中显示不同的内容。
</li>
<li>
目前发现v-bind指令可以将data返回的属性值绑定到标签属性上
</li>
<li>
目前发现v-on指令可以触发监听的函数方法
1.methods对象中定义的函数方法
2.原生DOM事件，如表单的submit动作，阻止表单的默认提交--> v-on:submit.prevent
</li>
<li>
v-model用于绑定表单控件元素，如input、textarea、select
1.textarea/input[type=text]，将data返回的属性值双向绑定到input的value属性上
2.input[type=checkbox]/input[type=radio]/select-option
  a.以上元素有value属性时，将data返回的属性值双向绑定到input的value属性上
  b.以上元素无value属性时，将data返回的属性值双向绑定到以上元素是否被选中，选中为true，未选中为false
</li>
<li>
v-if/v-show/slot标签都不会在文档排版中占位置，即不会像opacity样式那样占位置。
v-if与v-show区别
v-show 会在app初始化的时候编译并且渲染，并且在之后一直存在。当切换v-show模块时，只是简单的更改css。
v-if 当切换v-if模块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。 v-if 是惰性的，如果为false，则什么也不错-不编译，不渲染。 当第一次条件为真时，才开始编译。
建议
v-show的切换消耗比较低，但是不会重新渲染子组件，所以最好用于静态的内容或者不需要重新构建结构的组件。而 v-if 比较适合不太频繁的切换状态的组件。所以项目设计的时候，不要对复杂的业务设计模块太频繁的视图切换。尽量将静态内容和动态内容分离到不同的模块中。
总结
在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。
一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好
</li>

